#!/usr/bin/env python3
"""
Web Vulnerability Scanner
Detects common security vulnerabilities in web applications
"""

import requests
import argparse
import json
import sys
from urllib.parse import urljoin, parse_qs, urlparse
from bs4 import BeautifulSoup
from datetime import datetime
from typing import List, Dict, Tuple
import ssl
import socket
from jinja2 import Template
import warnings

warnings.filterwarnings('ignore', message='Unverified HTTPS request')


class VulnerabilityFinding:
    """Represents a vulnerability finding"""
    
    SEVERITY_LEVELS = {
        'CRITICAL': 4,
        'HIGH': 3,
        'MEDIUM': 2,
        'LOW': 1,
        'INFO': 0
    }
    
    def __init__(self, vulnerability_type: str, severity: str, url: str, 
                 description: str, recommendation: str, affected_param: str = None):
        self.vulnerability_type = vulnerability_type
        self.severity = severity
        self.url = url
        self.description = description
        self.recommendation = recommendation
        self.affected_param = affected_param
        self.timestamp = datetime.now()
    
    def to_dict(self):
        return {
            'type': self.vulnerability_type,
            'severity': self.severity,
            'url': self.url,
            'parameter': self.affected_param,
            'description': self.description,
            'recommendation': self.recommendation,
            'timestamp': self.timestamp.isoformat()
        }


class WebVulnerabilityScanner:
    """Main vulnerability scanner class"""
    
    # XSS Payloads
    XSS_PAYLOADS = [
        '<script>alert("XSS")</script>',
        '"><script>alert("XSS")</script>',
        "';alert('XSS');//",
        '<img src=x onerror=alert("XSS")>',
        '<svg onload=alert("XSS")>',
    ]
    
    # SQL Injection Payloads
    SQL_PAYLOADS = [
        "' OR '1'='1",
        "' OR '1'='1' --",
        "admin' --",
        "1' UNION SELECT NULL,NULL,NULL --",
        "' AND 1=2 UNION SELECT NULL,DATABASE() --",
    ]
    
    # Security Headers to check
    SECURITY_HEADERS = {
        'X-Frame-Options': 'Clickjacking protection',
        'X-Content-Type-Options': 'MIME sniffing protection',
        'Content-Security-Policy': 'XSS protection',
        'Strict-Transport-Security': 'HTTPS enforcement',
        'X-XSS-Protection': 'XSS protection (legacy)',
        'Referrer-Policy': 'Referrer information leakage',
    }
    
    # Outdated library patterns
    OUTDATED_LIBRARIES = {
        'jquery': {'pattern': r'jquery[.-]?(\d+\.\d+\.\d+)?', 'severity': 'HIGH'},
        'bootstrap': {'pattern': r'bootstrap[.-]?(\d+\.\d+)', 'severity': 'MEDIUM'},
    }
    
    def __init__(self, timeout: int = 10, verbose: bool = False):
        self.timeout = timeout
        self.verbose = verbose
        self.findings: List[VulnerabilityFinding] = []
        self.session = requests.Session()
        self.session.verify = False
    
    def log(self, message: str, level: str = 'INFO'):
        """Logging utility"""
        if self.verbose or level in ['ERROR', 'WARNING']:
            print(f"[{level}] {message}")
    
    def scan_url(self, url: str) -> List[VulnerabilityFinding]:
        """Main scanning function"""
        self.log(f"Starting scan on {url}")
        
        try:
            response = self.session.get(url, timeout=self.timeout)
            self.log(f"Status code: {response.status_code}")
        except requests.exceptions.RequestException as e:
            self.log(f"Error connecting to {url}: {str(e)}", 'ERROR')
            return self.findings
        
        # Run all vulnerability checks
        self.check_security_headers(url, response)
        self.check_xss_vulnerabilities(url, response)
        self.check_ssl_tls(url)
        self.check_cookies(url, response)
        self.check_outdated_libraries(response)
        self.check_information_disclosure(response)
        
        return self.findings
    
    def check_security_headers(self, url: str, response: requests.Response):
        """Check for missing security headers"""
        self.log("Checking security headers...")
        
        missing_headers = []
        for header, description in self.SECURITY_HEADERS.items():
            if header not in response.headers:
                missing_headers.append((header, description))
        
        if missing_headers:
            for header, description in missing_headers:
                finding = VulnerabilityFinding(
                    vulnerability_type='Missing Security Header',
                    severity='MEDIUM',
                    url=url,
                    description=f"Missing {header}: {description}",
                    recommendation=f"Add {header} header to all responses",
                    affected_param=header
                )
                self.findings.append(finding)
                self.log(f"Found: Missing {header}")
    
    def check_xss_vulnerabilities(self, url: str, response: requests.Response):
        """Check for XSS vulnerabilities"""
        self.log("Checking for XSS vulnerabilities...")
        
        # Check if response reflects user input without proper encoding
        soup = BeautifulSoup(response.text, 'html.parser')
        
        # Look for form fields
        forms = soup.find_all('form')
        
        if not forms:
            self.log("No forms found for XSS testing")
            return
        
        for form in forms:
            inputs = form.find_all('input')
            for input_field in inputs:
                input_name = input_field.get('name')
                if not input_name:
                    continue
                
                # Test XSS payloads
                for payload in self.XSS_PAYLOADS[:2]:  # Test first 2 payloads
                    try:
                        test_data = {input_name: payload}
                        test_response = self.session.post(url, data=test_data, timeout=self.timeout)
                        
                        # Check if payload is reflected in response
                        if payload in test_response.text and '<script>' in test_response.text:
                            finding = VulnerabilityFinding(
                                vulnerability_type='Cross-Site Scripting (XSS)',
                                severity='HIGH',
                                url=url,
                                description=f"XSS vulnerability in parameter '{input_name}'. User input is not properly sanitized.",
                                recommendation="Implement proper output encoding and input validation. Use security libraries for sanitization.",
                                affected_param=input_name
                            )
                            self.findings.append(finding)
                            self.log(f"Found XSS vulnerability in: {input_name}")
                            break
                    except requests.exceptions.RequestException:
                        continue
    
    def check_ssl_tls(self, url: str):
        """Check SSL/TLS configuration"""
        self.log("Checking SSL/TLS configuration...")
        
        try:
            parsed_url = urlparse(url)
            hostname = parsed_url.netloc.split(':')[0]
            
            context = ssl.create_default_context()
            with socket.create_connection((hostname, 443), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Check certificate validity
                    if not cert:
                        finding = VulnerabilityFinding(
                            vulnerability_type='SSL/TLS Configuration',
                            severity='CRITICAL',
                            url=url,
                            description="Could not verify SSL certificate",
                            recommendation="Ensure valid SSL certificate is installed and properly configured",
                        )
                        self.findings.append(finding)
                        self.log("SSL certificate verification failed")
        except Exception as e:
            self.log(f"Error checking SSL/TLS: {str(e)}", 'WARNING')
    
    def check_cookies(self, url: str, response: requests.Response):
        """Check cookie security flags"""
        self.log("Checking cookie security...")
        
        if 'set-cookie' not in response.headers:
            return
        
        cookie_header = response.headers.get('set-cookie', '')
        
        # Check for secure and httponly flags
        if cookie_header:
            if 'secure' not in cookie_header.lower():
                finding = VulnerabilityFinding(
                    vulnerability_type='Insecure Cookie',
                    severity='MEDIUM',
                    url=url,
                    description="Cookie is missing 'Secure' flag. Cookie can be transmitted over unencrypted connections.",
                    recommendation="Add 'Secure' flag to cookie to ensure transmission over HTTPS only",
                    affected_param='Secure flag'
                )
                self.findings.append(finding)
                self.log("Cookie missing Secure flag")
            
            if 'httponly' not in cookie_header.lower():
                finding = VulnerabilityFinding(
                    vulnerability_type='Insecure Cookie',
                    severity='MEDIUM',
                    url=url,
                    description="Cookie is missing 'HttpOnly' flag. Cookie can be accessed via JavaScript.",
                    recommendation="Add 'HttpOnly' flag to cookie to prevent XSS attacks from accessing it",
                    affected_param='HttpOnly flag'
                )
                self.findings.append(finding)
                self.log("Cookie missing HttpOnly flag")
    
    def check_outdated_libraries(self, response: requests.Response):
        """Check for outdated JavaScript libraries"""
        self.log("Checking for outdated libraries...")
        
        soup = BeautifulSoup(response.text, 'html.parser')
        scripts = soup.find_all('script')
        
        outdated_found = []
        for script in scripts:
            src = script.get('src', '')
            if 'jquery' in src.lower() and '3.' not in src:
                outdated_found.append(('jQuery', src))
            if 'bootstrap' in src.lower() and '5.' not in src:
                outdated_found.append(('Bootstrap', src))
        
        for lib_name, src in outdated_found:
            finding = VulnerabilityFinding(
                vulnerability_type='Outdated Library',
                severity='MEDIUM',
                url=response.url,
                description=f"Outdated {lib_name} library detected: {src}",
                recommendation=f"Update {lib_name} to the latest version",
                affected_param=src
            )
            self.findings.append(finding)
            self.log(f"Found outdated library: {lib_name}")
    
    def check_information_disclosure(self, response: requests.Response):
        """Check for information disclosure"""
        self.log("Checking for information disclosure...")
        
        # Check for verbose error messages
        error_patterns = ['fatal error', 'sql error', 'exception', 'traceback', 'stack trace']
        
        for pattern in error_patterns:
            if pattern.lower() in response.text.lower():
                finding = VulnerabilityFinding(
                    vulnerability_type='Information Disclosure',
                    severity='LOW',
                    url=response.url,
                    description=f"Verbose error messages detected: {pattern}",
                    recommendation="Implement custom error pages that don't expose technical details",
                    affected_param=pattern
                )
                self.findings.append(finding)
                self.log(f"Found information disclosure: {pattern}")
                break
    
    def generate_html_report(self, filename: str, urls: List[str]):
        """Generate HTML report"""
        self.log(f"Generating report: {filename}")
        
        # Group findings by severity
        by_severity = {}
        for finding in self.findings:
            severity = finding.severity
            if severity not in by_severity:
                by_severity[severity] = []
            by_severity[severity].append(finding)
        
        # Sort by severity level
        sorted_findings = []
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO']:
            if severity in by_severity:
                sorted_findings.extend(by_severity[severity])
        
        html_template = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Web Vulnerability Scan Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
                .header { background: #2c3e50; color: white; padding: 20px; border-radius: 5px; }
                .summary { background: white; padding: 15px; margin: 20px 0; border-left: 4px solid #3498db; }
                .finding { background: white; padding: 15px; margin: 15px 0; border-radius: 5px; border-left: 4px solid; }
                .critical { border-left-color: #e74c3c; }
                .high { border-left-color: #e67e22; }
                .medium { border-left-color: #f39c12; }
                .low { border-left-color: #3498db; }
                .severity { font-weight: bold; padding: 5px 10px; border-radius: 3px; display: inline-block; }
                .severity-critical { background: #e74c3c; color: white; }
                .severity-high { background: #e67e22; color: white; }
                .severity-medium { background: #f39c12; color: white; }
                .severity-low { background: #3498db; color: white; }
                .recommendation { background: #ecf0f1; padding: 10px; margin-top: 10px; border-radius: 3px; }
                .stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 20px 0; }
                .stat-box { background: white; padding: 15px; border-radius: 5px; text-align: center; }
                .stat-number { font-size: 32px; font-weight: bold; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Web Vulnerability Scan Report</h1>
                <p>Report generated: {{ timestamp }}</p>
                <p>URLs scanned: {{ urls }}</p>
            </div>
            
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-number" style="color: #e74c3c;">{{ critical }}</div>
                    <div>Critical</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" style="color: #e67e22;">{{ high }}</div>
                    <div>High</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" style="color: #f39c12;">{{ medium }}</div>
                    <div>Medium</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" style="color: #3498db;">{{ low }}</div>
                    <div>Low</div>
                </div>
            </div>
            
            <div class="summary">
                <h2>Summary</h2>
                <p>Total vulnerabilities found: <strong>{{ total }}</strong></p>
                {% if total == 0 %}
                    <p style="color: green;">No vulnerabilities detected in this scan.</p>
                {% else %}
                    <p>Review the detailed findings below and implement the recommended remediation steps.</p>
                {% endif %}
            </div>
            
            <h2>Detailed Findings</h2>
            {% for finding in findings %}
            <div class="finding {{ finding.severity|lower }}">
                <h3>{{ finding.vulnerability_type }}</h3>
                <p><span class="severity severity-{{ finding.severity|lower }}">{{ finding.severity }}</span></p>
                <p><strong>URL:</strong> {{ finding.url }}</p>
                {% if finding.affected_param %}
                <p><strong>Parameter:</strong> {{ finding.affected_param }}</p>
                {% endif %}
                <p><strong>Description:</strong> {{ finding.description }}</p>
                <div class="recommendation">
                    <strong>Recommendation:</strong> {{ finding.recommendation }}
                </div>
            </div>
            {% endfor %}
        </body>
        </html>
        """
        
        template = Template(html_template)
        
        # Count by severity
        severity_counts = {
            'critical': len([f for f in self.findings if f.severity == 'CRITICAL']),
            'high': len([f for f in self.findings if f.severity == 'HIGH']),
            'medium': len([f for f in self.findings if f.severity == 'MEDIUM']),
            'low': len([f for f in self.findings if f.severity == 'LOW']),
        }
        
        html = template.render(
            timestamp=datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            urls=', '.join(urls),
            findings=sorted_findings,
            total=len(self.findings),
            critical=severity_counts['critical'],
            high=severity_counts['high'],
            medium=severity_counts['medium'],
            low=severity_counts['low']
        )
        
        with open(filename, 'w') as f:
            f.write(html)
        
        self.log(f"Report saved to {filename}")


def main():
    parser = argparse.ArgumentParser(
        description='Web Vulnerability Scanner - Detect common security issues',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python scanner.py -u https://example.com
  python scanner.py -u https://example.com,https://example2.com -o report.html -v
  python scanner.py -u https://example.com -t 30
        """
    )
    
    parser.add_argument('-u', '--url', required=True, 
                        help='Target URL(s) to scan (comma-separated for multiple)')
    parser.add_argument('-o', '--output', default='vulnerability_report.html',
                        help='Output report filename')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='Enable verbose output')
    parser.add_argument('-t', '--timeout', type=int, default=10,
                        help='Request timeout in seconds')
    
    args = parser.parse_args()
    
    # Parse URLs
    urls = [url.strip() for url in args.url.split(',')]
    
    # Create scanner
    scanner = WebVulnerabilityScanner(timeout=args.timeout, verbose=args.verbose)
    
    # Scan each URL
    for url in urls:
        if not url.startswith('http'):
            url = 'https://' + url
        scanner.scan_url(url)
    
    # Generate report
    scanner.generate_html_report(args.output, urls)
    
    # Print summary
    print(f"\n{'='*60}")
    print(f"Scan complete!")
    print(f"Total vulnerabilities found: {len(scanner.findings)}")
    
    if scanner.findings:
        severity_counts = {}
        for finding in scanner.findings:
            severity_counts[finding.severity] = severity_counts.get(finding.severity, 0) + 1
        
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
            if severity in severity_counts:
                print(f"  {severity}: {severity_counts[severity]}")
    
    print(f"Report saved to: {args.output}")
    print(f"{'='*60}\n")


if __name__ == '__main__':
    main()
